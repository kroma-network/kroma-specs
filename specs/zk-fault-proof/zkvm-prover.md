# zkVM Prover

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**

- [Overview](#overview)
- [zkVM Proving System](#zkvm-proving-system)
  - [Guest Program](#guest-program)
  - [Host Program](#host-program)
  - [Public Values of Proof](#public-values-of-proof)
  - [Proving Fault](#proving-fault)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

<!-- All glossary references in this file. -->

[g-zk-fault-proof]: ../glossary.md#zk-fault-proof
[g-state]: ../glossary.md#state
[g-l2-chain-derivation]: ../glossary.md#l2-chain-derivation
[g-sequencer-batch]: ../glossary.md#sequencer-batch
[g-colosseum-contract]: ../glossary.md#colosseum-contract

## Overview

A prover is responsible for generating proof using the [Plonky3](https://github.com/Plonky3/Plonky3/)
for a target blocks. This proof provides claims regarding the legitimacy of block data and state transitions.
A prover plays a vital role in the challenge process, serving as a key component of the challenger.

A [ZK fault proof][g-zk-fault-proof] demonstrates that a [state][g-state] transition from S to Sâ€™ is valid based on the
transactions within the block. While this may seem similar to a validity proof, the key difference lies in its
purpose. The ZK fault proof is used to demonstrate that a state transition from `S` to `S''` is incorrect by
providing evidence of a valid state transition from `S` to `S'`.

## zkVM Proving System

The zkVM (Zero-Knowledge Virtual Machine) is a virtual machine that executes guest program compiled with a specified
compiler generating zero-knowledge proofs for their execution. The guest program can be written in standard programming
languages, such as Rust and Go.

In current version of zkVM fault proof, the proving scheme is based on [SP1] by Succinct.

[SP1]: https://github.com/succinctlabs/sp1

### Guest Program

For ZK Fault Dispute Game, the guest program is an extension of [L2 Chain Derivation][g-l2-chain-derivation] that
includes a connectivity check among the blocks from L1 origin block to the specified block `C`. The hash of Block
`C` is determined as the parent hash stored when the ZK Fault Dispute Game is created by calling `createChallenge` of
the [Colosseum contract][g-colosseum-contract].

If the attacker manipulates any data within the extension of L2 Chain Derivation, it will affect the block hash `C`.
This is because all data is ultimately linked to the block hash `C` through the hash chain. Therefore if any data
manipulating attack can be thwarted by checking the block hash `C` value. For example, if an attacker creates a proof
using a transaction that is not included in the [sequencer batch][g-sequencer-batch], the block `C` value will change,
preventing them from winning the challenge.

Guest program used in this system is implemented based on [Kona].

[Kona]: https://github.com/anton-rs/kona

### Host Program

The host program is a main part of the prover, responsible for delivering the guest program and its input to the zkVM.
The host program first executes the guest program ([Kona]) to gather the necessary data. Then, during the second
execution within the zkVM, the collected data is provided as input. After the zkVM execution is completed, the Host
program retrieves the SP1 zkVM proof along with the public inputs disclosed by the guest program.

### Public Values of Proof

To mark which blocks have been executed, the proof publicly reveals the following data.

``` plain
1. Output root at the parent block of the target
2. Output root at the target block
3. Hash of the block C
```

### Proving Fault

The ZK proof generated by a prover can be verified on chain.

```solidity
    /**
     * @notice Proves that a specific output is invalid using zkVM proof.
     *         This function can only be called in the READY_TO_PROVE and ASSERTER_TIMEOUT statuses.
     *
     * @param _outputIndex Index of the L2 checkpoint output.
     * @param _pos         Position of the last valid segment.
     * @param _zkVmProof   The public input and proof using zkVM.
     */
    function proveFaultWithZkVm(
        uint256 _outputIndex,
        uint256 _pos,
        Types.ZkVmProof calldata _zkVmProof
    ) external;
```

The verify function of `SP1VerifierPlonk` contract, which will be used in `proveFaultZkVm` for verification of provided
ZK proof, is implemented following the below interface.

```solidity
interface SP1VerifierPlonk {
    /// @notice Verifies a proof with given public values and vkey.
    /// @param programVKey The verification key for the RISC-V program.
    /// @param publicValues The public values encoded as bytes.
    /// @param proofBytes The proof of the program execution the SP1 zkVM encoded as bytes.
    function verifyProof(
        bytes32 programVKey,
        bytes calldata publicValues,
        bytes calldata proofBytes
    ) external view;
}
```

where programVKey is the verification key for the RISC-V program used in [SP1] prover, and
the `publicValues` is concatenated value of public values as described [above](#public-values-of-proof).
