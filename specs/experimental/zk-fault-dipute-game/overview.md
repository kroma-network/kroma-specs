# ZK Fault Dispute Game
<!-- All glossary references in this file. -->

[g-zk-fault-proof]: ../../glossary.md#zk-fault-proof
[g-l2-chain-derivation]: ../../glossary.md#l2-chain-derivation
[g-sequencer-batch]: ../../glossary.md#sequencer-batch
[g-dispute-game]: ../../experimental/zk-fault-dipute-game/overview.md

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**

- [ZK Fault Dispute Game](#zk-fault-dispute-game)
  - [Overview](#overview)
  - [ZK Fault Dispute Game Creation](#zk-fault-dispute-game-creation)
  - [Challenge Creation](#challenge-creation)
  - [Dissection](#dissection)
  - [Proving Fault using ZKVM](#proving-fault-using-zkvm)
    - [Prover](#prover)
    - [zkVM Proof](#zkvm-proof)
      - [Guest Program](#guest-program)
      - [Host Program](#host-program)
      - [Public Values of Proof](#public-values-of-proof)
      - [Zk Verify contract](#zk-verify-contract)
  - [Resolution of ZK Fault Dispute Game](#resolution-of-zk-fault-dispute-game)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## Overview

## ZK Fault Dispute Game Creation

## Challenge Creation

## Dissection

## Proving Fault using ZKVM

### Prover

A prover plays a vital role in the challenge process, acting as an integral part of the challenger responsible
for generating proof for the target block. This proof substantiates claims regarding the legitimacy of block data
and state transitions.
A [ZK fault proof][g-zk-fault-proof] demonstrates that a state transition from S to S’ is valid based on the
transactions within the block. While this may seem similar to a validity proof, the key difference lies in its
purpose. The ZK fault proof is used to demonstrate that a state transition from S to S’’ is incorrect by
providing evidence of a valid state
transition from S to S’.

### zkVM Proof

The zkVM (Zero-Knowledge Virtual Machine) is a virtual machine that executes guest program compiled with a specified
compiler generating zero-knowledge proofs for their execution. The guest program can be written in standard programming
languages, such as Rust and Go.

#### Guest Program

In the case of the ZK fault proof, the guest program is an extension of [L2 Chain Derivation][g-l2-chain-derivation]
that includes a connectivity check among the blocks from L1 origin block and the specified block `C`. The hash of
Block `C` is determined as the parent hash stored when the challenger initialized the [Dispute Game][g-dispute-game]
by calling `create()` of the Dispute Game Factory.
If the guest program consists only of L2 Chain Derivation, the challenger could create a proof with transactions that
are not the actual transactions of the target block by manipulating an L1 Block that contains an
[g-sequencer-batch][g-sequencer-batch].

#### Host Program

The host program is a main part of the prover, responsible for delivering the guest program and its input to the zkVM.
The host program first executes the same logic as the guest program to gather the necessary PreImages. Finally,
the host program delivers the guest program and the PreImages to the zkVM to obtain the zkVM proof.

#### Public Values of Proof

To mark which blocks have been executed, the proof publicly reveals the following data.

``` plain
1. Output Root at parent block of the target
2. Output Root at the target block
3. Hash of the block C
```

#### Zk Verify contract

The proof generated by a prover can be verified on a verifier contract that includes the following interface.
The verification in a challenge process is implemented using the verify function provided by the verifier contract.

``` solidity
interface ZKVerifier {
    /// @notice The entrypoint for verifying the proof of zk fault proof.
    /// @param _proofBytes The encoded proof.
    /// @param _publicValues The encoded public values.
    /// @return parentOutputRoot output root at parent block of the target.
    /// @return outputRoot output root at the target block.
    /// @return L1EndHash hash of the l1 end block.
    function verify(
      bytes calldata _publicValues, 
      bytes calldata _proofBytes
    ) public view returns (
      bytes32 parentOutputRoot, 
      bytes32 outputRoot, 
      bytes32 L1EndHash
    );
}
```

## Resolution of ZK Fault Dispute Game
