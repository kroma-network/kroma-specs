# Asset Manager

<!-- All glossary references in this file. -->

[g-l2-output]: ../../glossary.md#l2-output-root
[g-validator]: ../../glossary.md#validator

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**

- [Overview](#overview)
- [Composition of Asset Manager](#composition-of-asset-manager)
- [Undelegation Delay of 7 days](#undelegation-delay-of-7-days)
- [Calculation of Slashing Amount](#calculation-of-slashing-amount)
- [Difference from ERC-4626](#difference-from-erc-4626)
  - [Non-transferable Shares](#non-transferable-shares)
  - [Global Vault Structure](#global-vault-structure)
- [Security Considerations](#security-considerations)
  - [Virtual Offset](#virtual-offset)
  - [Virtual Share](#virtual-share)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## Overview

The Asset Manager oversees the delegation and undelegation of KRO tokens and Kroma Guardian House (KGH) NFTs.
It calculates and distributes rewards based on [output root][g-l2-output] submissions and manages slashing penalties.
KRO and KGH delegators delegate their assets into the system and receive rewards upon undelegation. The Asset Manager
supervises the assets of all [validators][g-validator] and delegators within the Kroma validator system.

## Composition of Asset Manager

Asset Manager incorporates a `Vault` component, inspired by the ERC-4626 standard. Its responsibilities include:

1. Management of delegated KRO and KGH

    - Adopts the structure of ERC-4626 to issue shares when KRO and KGH are delegated.

2. Slashing and Reward Calculation

    - Calculates rewards for delegators based on the output root submission and manages slashing of assets when
   challenges occur.

Each validator registered in `ValidatorManager` has a corresponding `Vault` struct. The `Vault` struct is defined as
follows:

```solidity
struct Vault {
    Asset asset;
    Pending pending;
    mapping(address => KroDelegator) kroDelegators;
    mapping(address => KghDelegator) kghDelegators;
}
```

The `Asset` and `Pending` structs contain global information such as the total number of KROs in the `Vault`. In
contrast, the `KroDelegator` and `KghDelegator` structs store individual information about each delegator,
such as the number of shares he hold in the `Vault`.

The `Vault` defines separate assets and shares for KRO and KGH, allowing for distinct reward distribution
mechanisms for KRO delegators and KGH delegators.

|       | asset                                                                                        | share                                                   |
|-------|----------------------------------------------------------------------------------------------|---------------------------------------------------------|
| `KRO` | KRO delegated by delegators & validators + Cumulative base reward + KRO inside delegated KGH | Shares from KRO delegation and KRO inside delegated KGH |
| `KGH` | Virtual KRO generated by KGH delegation + Cumulative boosted reward                          | Shares from KGH delegation                              |

Consequently, there are two types of shares that a delegator can receive: `kroShare` and `kghShare`. For example,
if a delegator delegates KRO, they receive `kroShare` based on the current state of the `Vault`. The number of shares
issued is calculated similarly to ERC-4626, as follows:

$$kroShare = kroAsset \times \frac{totalKroShares+10^{offset}}{totalKroAssets+1}$$

If a delegator wants to undelegate all their assets by burning `kroShare`, the amount of KRO they receive is calculated
as follows:

$$kroAsset = kroShare \times \frac{totalKroAssets+1}{totalKroShares+10^{offset}}$$

When KGH is delegated, it is considered as delegating an amount of KRO equal to `VKRO_PER_KGH` per KGH, and
corresponding shares are issued.

If the same amount of shares is issued for each KGH, then holders who delegate later would gain a share of the
previously accumulated boosted rewards. To prevent this, when KGH is delegated, it is converted to a fixed amount
of virtual KRO, which is then used to calculate the shares that the user should receive.

Information related to the assets and shares of each validator is stored in the following `Asset` struct. Note that the
base reward is included in the `totalKro` field, while `boostedReward` field stores the total amount of boosted rewards.

```solidity
struct Asset {
    uint128 totalKro;
    uint128 totalKroShares;
    uint128 totalKgh;
    uint128 totalKroInKgh;
    uint128 totalKghShares;
    uint128 validatorKro;
    uint128 boostedReward;
    uint128 validatorRewardKro;
}
```

## Undelegation Delay of 7 days

To prevent abuse such as attempting to receive unintended and unjustified rewards or avoiding slashing through various
forms of manipulation, all undelegation and reward claims are subject to a one-week delay. Without this 7-day delay,
the following abuses could occur:

1. Exploiting the fact that output finalization takes one week, a submitter could delegate a large amount of KRO right
before output finalization, and then undelegate it immediately after finalization. This way, the delegator could take
the rewards with almost no risk.
2. When a challenge occurs, if the validator to whom assets were delegated is likely to be slashed, the user could
undelegate their assets to avoid the slashing.

To address these edge cases, funds in the undelegation state will remain pending for a week, and during this period,
even if rewards are generated from output finalization, they will not be retroactively applied.

However, if slashing occurs due to a challenge, assets in the pending state will also be included in the slashing scope.
This measure is to prevent abuse as mentioned in the second case. If pending assets were not subject to slashing,
users could undelegate their assets immediately to avoid slashing regardless of the challenge outcome. This would
reduce the rewards for the winner of the challenge, decrease the incentive to create challenges, and negatively impact
the network's security. Therefore, assets in the pending state must be included within the slashing scope.

To achieve this, assets in the pending state must be managed separately from assets delegated to the vault.
Information related to this is stored in the `Vault` within the following `Pending` struct:

```solidity
struct Pending {
    uint128 totalPendingAssets;
    uint128 totalPendingBoostedRewards;
    uint128 totalPendingKroShares;
    uint128 totalPendingKghShares;
    uint128 totalPendingValidatorRewards;
    uint256[] claimRequestTimes;
    mapping(uint256 => uint128) pendingValidatorRewards;
}
```

When a user initiates undelegation, the requested amount of assets and shares are stored separately.
After the one-week delay ends, the total pending assets, the user's requested pending shares, and the total pending
shares are used to calculate the final amount of assets to be received. The pending shares and undelegate request time
information for each delegator, along with the shares of each delegator, are saved in the following structs:

```solidity
struct KroDelegator {
    uint128 shares;
    uint256[] undelegateRequestTimes;
    mapping(uint256 => uint128) pendingKroShares;
}

struct KghDelegator {
    mapping(uint256 => KghDelegatorShares) shares;
    uint256[] undelegateRequestTimes;
    mapping(uint256 => uint256[]) pendingKghIds;
    mapping(uint256 => KghDelegatorShares) pendingShares;
}
```

## Calculation of Slashing Amount

If a validator failed to win a challenge, assets of the validator and delegators who delegated their assets to the
validator are subject to slashing. The slashing amount is determined by the following constants:

| Name                  | Value |
|-----------------------|-------|
| `SLASHING_RATE`       | TBD   |
| `SLASHING_RATE_DENOM` | 1000  |
| `MIN_SLASHING_AMOUNT` | TBD   |

If the slashing amount is too low, the incentive to create challenges would decrease, which could lead to a decrease
in the network's security. Therefore, `MIN_SLASHING_AMOUNT` is set to ensure the minimum challenge reward.

The slashing amount is calculated as follows:

$$
\text{slashingAmount} = \max \left( \frac{(\text{totalAssets} - \text{totalKroInKgh}) \times \text{slashingRate}}
{\text{slashingRateDenom}}, \text{minSlashingAmount} \right)
$$

Note that KROs inside KGH are not subject to slashing.

## Difference from ERC-4626

### Non-transferable Shares

Unlike ERC-4626, the shares in `Vault` are designed to be non-transferable to any accounts except for the delegator
and Asset Manager contract. This is implemented to prevent the following edge cases:

- Transferring shares related to the validator's `minRegisterAmount` (minimum amount of KRO to be a validator) to
  another address.
- Transferring shares related to KRO within KGH to another address.

Those cases can lead to inconsistent state management of the `Vault`, which could result in unexpected behavior.

### Global Vault Structure

In ERC-4626, each contract typically has a single ERC-20 share. However, `Vault` in Asset Manager manages
self-delegation, delegation, and rewards for all validators within a single contract.
Therefore, `Vault` operates a mapping with validator addresses as keys and stores the state of assets, shares,
and rewards for each validator's vault within the mapping.

## Security Considerations

To prevent a [vault inflation attack](https://docs.openzeppelin.com/contracts/4.x/erc4626#inflation-attack), two
additional elements are introduced when calculating the amount of shares corresponding to delegated and undelegated
assets.

### Virtual Offset

The exchange rate between shares and assets is artificially increased to prevent attacks due to rounding issues.
This means increasing the decimal places for shares so that each asset maps to $10^{\delta}$ shares.

### Virtual Share

To maintain the exchange rate defined by the virtual offset even in an empty vault where no assets have been delegated
yet, virtual assets and shares are included in the share calculation logic as follows.

$$asset = share \times \frac{totalKroAssets+1}{totalKroShares+10^{offset}}$$
